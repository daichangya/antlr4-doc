# Left-recursive rules

某些通用语言结构最自然的表达是左递归。例如C声明符和算术表达式。不幸的是,算术表达式的左递归规范通常是模棱两可的,但是比典型的自顶向下语法所要求的多个级别更容易写出。这是带有左递归表达式规则的样本ANTLR 4语法:

```
stat: expr '=' expr ';' //e.g., x=y; or x=f(x);
    | expr ';'          //e.g., f(x); or f(g(x));
    ;
expr: expr '*' expr
    | expr '+' expr
    | expr '(' expr ')' //f(x)
    | id
    ;
```

在直接上下文无关的语法中,这样的规则是模棱两可的,因为`1+2*3`可以将任一运算符解释为首先出现,但是ANTLR使用语义谓词将其重写为非左递归且无歧义:

```
expr[int pr] : id
               ( {4 >= $pr}? '*' expr[5]
               | {3 >= $pr}? '+' expr[4]
               | {2 >= $pr}? '(' expr[0] ')'
               )*
             ;
```

谓词通过将当前运算符的优先级与先前运算符的优先级进行比较来解决歧义。expr [pr]的扩展只能匹配优先级达到或超过pr的那些子表达式。

## Formal rules

正式的4.0、4.1 ANTLR左递归消除规则已针对4.2进行了更改(简化),并在[ALL(*)技术报告](http://www.antlr.org/papers/allstar-techreport.pdf ):

*二进制表达式是包含规则的递归调用的表达式,作为替代的第一个和最后一个元素。
*后缀表达式包含规则的递归调用,作为替代的第一个元素,但不作为最后一个元素。
*前缀表达式包含规则的递归调用,作为替代的最后一个元素,而不是第一个元素。

没有“三元”表达式之类的东西,它们只是变相的二进制表达式。

正确的关联性说明符以前是基于单个标记的,但无论如何都是在替代的基础上完成的,因此该选项现在位于单个替代项上。例如,

```
e : e '*' e
  | e '+' e
  |<assoc=right> e '?' e ':' e
  |<assoc=right> e '=' e
  | INT
  ;
```

如果您的4.0或4.1语法使用右联想三元运算符,则需要更新语法以在替代运算符上包含`<assoc=right>`。为了平滑过渡,令牌引用上仍然允许使用`<assoc=right>`,但是将其忽略。