# Semantic Predicates

语义谓词`{...}?`是用目标语言编写的布尔表达式,表示沿谓词“保护”的路径继续进行语法分析的有效性。谓词可以像动作一样出现在解析器规则内的任何位置,但只有那些出现在替代项左边缘的谓词才能影响预测(在替代项之间进行选择)。本节提供有关在解析器和词法分析器规则中使用语义谓词的所有详细信息。让我们从更深入地分析解析器如何将谓词合并到解析决策中开始。

## Making Predicated Parsing Decisions

ANTLR的一般决策策略是找到所有可行的替代方案,然后忽略当前评估为假的谓词保护的替代方案。(一个可行的替代方案是与当前输入匹配的替代方案。)如果剩下多个可行的替代方案,则解析器将选择决策中首先指定的替代方案。

考虑C ++的一种变体,其中数组引用也使用括号而不是方括号。如果仅预测其中一种选择,则expr仍然存在不确定的决定:

```
expr: ID '(' expr ')' //array reference (ANTLR picks this one)
 	| {istype()}? ID '(' expr ')' //ctor-style typecast
 	| ID '(' expr ')' //function call
 	;
```

在这种情况下,所有三个替代方案均可用于输入`x(i)`。如果`x`不是类型名称,则谓词的计算结果为false,仅将第一个和第三个替代项作为expr的可能匹配项。ANTLR自动选择与数组引用匹配的第一个替代方案以解决歧义。由于谓词太少而将ANTLR留给一个以上可行的选择可能不是一个好主意。最好用至少n-1个谓词覆盖n个可行的替代项。换句话说,不要建立谓词过少的规则,例如expr。

有时,解析器会找到与单个选择关联的多个可见谓词。别担心。ANTLR只是将谓词与适当的逻辑运算符结合在一起,以动态地构想单个元谓词。

例如,规则`stat`中的决策将expr的两个选择中的谓词与`||`运算符结合起来,以保护第二个stat选择:

```
stat: decl | expr ;
decl: ID ID ;
expr: {istype()}? ID '(' expr ')' //ctor-style typecast
 	| {isfunc()}? ID '(' expr ')' //function call
 	;
```

仅当`istype()||isfunc()`评估为true时,解析器才会根据stat预测expr。这是有道理的,因为解析器仅应在即将出现的`ID`是类型名或函数名时选择匹配表达式。在这种情况下只测试其中一个谓词是没有意义的。请注意,当解析器本身到达`expr`时,解析决策将单独测试谓词,每个备选谓词一个。

如果一个序列中出现多个谓词,则解析器将它们与`&&`运算符结合在一起。例如,考虑将`stat`更改为在调用`toexpr`之前包含谓词:

```
stat: decl | {java5}? expr ;
```

现在,如果`java5&&(istype()||isfunc())`评估为true,则解析器将仅预测第二个替代项。

现在转到谓词本身中的代码,请牢记以下准则。

即使解析器没有做出决定,谓词也会停用替代项,从而导致规则失败。当规则只有一个备选方案时,就会发生这种情况。没有选择的余地,但是ANTLR将谓词评估为正常解析过程的一部分,就像对动作一样。这意味着以下规则始终不匹配。

```
prog: {false}? 'return' INT ; //throws FailedPredicateException
```

ANTLR在生成的解析器中将语法中的`{false}?`转换为条件的:

```
if ( !false ) throw new FailedPredicateException(...);
```

到目前为止,我们所见过的所有谓词都是可见的,可用于预测过程,但这并非总是如此。

## Finding Visible Predicates

解析器将不会在预测期间评估在操作或令牌引用之后发生的谓词。首先考虑一下动作和谓词之间的关系。

ANTLR不知道操作原始代码中包含什么,因此它必须假定任何谓词都可能取决于该操作的副作用。想象一下一个操作,该操作计算了值`x`和一个测试了`x`的谓词。在执行创建`x`的操作之前评估该谓词将违反语法中隐含的操作顺序。

更重要的是,解析器必须先确定要匹配的替代方案,然后才能执行操作。那是因为动作有副作用,我们不能撤消诸如print语句之类的事情。例如,在以下规则中,解析器在提交该替代方案之前无法在`{java5}?`谓词之前执行操作。

```
@members {boolean allowgoto=false;}
stat: {System.out.println("goto"); allowgoto=true;} {java5}? 'goto' ID ';'
 	| ...
 	;
```

如果我们无法在预测过程中执行该操作,则不应评估`{java5}?`谓词,因为它取决于该操作。

预测过程也看不到令牌引用。令牌引用具有使输入符号前进的副作用。如果解析器将其移到令牌引用上,则测试当前输入符号的谓词将发现自身不同步。例如,在下面的语法中,谓词期望`getCurrentToken`返回`ID`令牌。

```
stat: '{' decl '}'
 	| '{' stat '}'
 	;
decl: {istype(getCurrentToken().getText())}? ID ID ';' ;
expr: {isvar(getCurrentToken().getText())}? ID ;
```

stat中的决定无法测试这些谓词,因为在stat开始时,当前标记是向左卷曲的。为了保留语义,ANTLR不会在该决定中测试谓词。

可见谓词是预测在遇到动作或令牌之前遇到的谓词。预测过程会忽略不可见谓词,将它们视为不存在。

在极少数情况下,即使特定决策可见,解析器也无法使用谓词。这使我们进入了下一个精美印刷主题。

## Using Context-Dependent Predicates

取决于周围规则的参数或局部变量的谓词被视为上下文相关谓词。显然,我们只能在定义它们的规则内评估这些谓词。例如,下面的prog中的测试上下文相关谓词`{$i<=5}?`的决定没有任何意义。该`$i`局部变量甚至没有在`prog`中定义。

```
prog: vec5
 	| ...
 	;
vec5
locals [int i=1]
 	: ( {$i<=5}? INT {$i++;} )* //match 5 INTs
 	;
```

ANTLR会忽略无法在适当上下文中进行评估的上下文相关谓词。通常,适当的上下文只是定义谓词的规则,但有时解析器甚至无法从同一规则中评估上下文相关的谓词!在自适应LL(*)预测期间,会在运行时动态地检测这些情况。

例如,对stat中else子规则的可选分支的预测低于“结束” stat的末尾,并继续在调用prog规则中查找符号。

```
prog: stat+ ; //stat can follow stat
stat
locals [int i=0]
 	: {$i==0}? 'if' expr 'then' stat {$i=5;} ('else' stat)?
 	| 'break' ';'
 	;
```

预测过程试图找出if语句之后的条件,而不是else子句。由于输入可以连续包含多个统计信息,因此else子规则的可选分支的预测会重新输入stat。当然,这一次,它将获得值为0而不是5的`$i`的新副本。ANTLR会忽略上下文相关谓词`{$i==0}?`,因为它知道解析器不在原始统计信息中。呼叫。谓词将测试`$i`的其他版本,因此解析器无法评估它。

词法分析器中谓词的精细印刷或多或少遵循这些相同的准则,除了词法分析器规则不能具有参数和局部变量。让我们在下一部分中查看所有特定于词法分析器的指南。

## Predicates in Lexer Rules

在解析器规则中,谓词必须出现在替代项的左边缘,以帮助进行替代项预测。另一方面,词法分析器更喜欢词法分析器规则右侧的谓词,因为它们在看到标记的整个文本之后选择规则。从技术上来说,词法分析器规则中的谓词可以位于规则内的任何位置。有些职位可能比其他职位更有效率;ANTLR不保证最佳位置。即使在单个令牌匹配期间,词法分析器规则中的谓词也可能会多次执行。您可以为每个词法分析器规则嵌入多个谓词,并且在匹配期间词法分析器到达它们时会对其进行评估。

松散地说,词法分析器的目标是选择与输入字符最多匹配的规则。在每个字符上,词法分析器确定哪些规则仍然可行。最终,只有一条规则仍然可行。那时,词法分析器根据规则的标记类型和匹配的文本创建标记对象。

有时,词法分析器面临着不止一个可行的匹配规则。例如,输入枚举将匹配`ENUM`规则和`ID`规则。如果枚举后的下一个字符为空格,则任何规则都不能继续执行。词法分析器通过选择语法中首先指定的可行规则来解决歧义。这就是为什么我们必须将关键字规则放在这样的标识符规则之前:

```
ENUM : 'enum' ;
ID : [a-z]+ ;
```

另一方面,如果输入`enum`之后的下一个字符是字母,则仅`ID`是可行的。

通过修剪可行的词法分析器规则集来发挥谓词的作用。当词法分析器遇到错误谓词时,它会停用该规则,就像解析器会停用具有错误谓词的替代项一样。

像解析器谓词一样,词法分析器谓词不能依赖于词法分析器操作的副作用。这是因为只有在词法分析器正确确定要匹配的规则之后才能执行操作。由于谓词是规则选择过程的一部分,因此它们不能依赖动作副作用。词法分析器操作必须出现在词法分析器规则中的谓词之后。例如,这是将枚举匹配为词法分析器中的关键字的另一种方法:

```
ENUM: [a-z]+ {getText().equals("enum")}?
	   {System.out.println("enum!");}
    ;
ID  : [a-z]+ {System.out.println("ID "+getText());} ;
```

`ENUM`中的打印动作最后出现,并且仅在当前输入匹配`[a-z]+`并且谓词为true时执行。让我们构建和测试`Enum3`看看它是否区分枚举和标识符:

```bash
$ antlr4 Enum3.g4
$ javac Enum3.java
$ grun Enum3 tokens
=> 	enum abc
=> 	EOF
<= 	enum!
 	ID abc
```

效果很好,但实际上只是出于教学目的。使用以下简单规则将枚举关键字匹配起来更容易理解,并且效率更高:

```
ENUM : 'enum' ;
```